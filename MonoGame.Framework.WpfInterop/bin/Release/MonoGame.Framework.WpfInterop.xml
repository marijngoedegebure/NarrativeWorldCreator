<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MonoGame.Framework.WpfInterop</name>
    </assembly>
    <members>
        <member name="T:MonoGame.Framework.WpfInterop.D3D11Host">
            <summary>
            Host a Direct3D 11 scene.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Host.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MonoGame.Framework.WpfInterop.D3D11Host"/> class.
            </summary>
        </member>
        <member name="P:MonoGame.Framework.WpfInterop.D3D11Host.IsInDesignMode">
            <summary>
            Gets a value indicating whether the controls runs in the context of a designer (e.g.
            Visual Studio Designer or Expression Blend).
            </summary>
            <value>
            <see langword="true" /> if controls run in design mode; otherwise, 
            <see langword="false" />.
            </value>
        </member>
        <member name="P:MonoGame.Framework.WpfInterop.D3D11Host.GraphicsDevice">
            <summary>
            Gets the graphics device.
            </summary>
            <value>The graphics device.</value>
        </member>
        <member name="P:MonoGame.Framework.WpfInterop.D3D11Host.Services">
            <summary>
            Default services collection.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Host.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
            <summary>
            Raises the <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> event, using the specified 
            information as part of the eventual event data.
            </summary>
            <param name="sizeInfo">Details of the old and new size involved in the change.</param>
        </member>
        <member name="T:MonoGame.Framework.WpfInterop.D3D11Image">
            <summary>
            Wraps the <see cref="T:System.Windows.Interop.D3DImage"/> to make it compatible with Direct3D 11.
            </summary>
            <remarks>
            The <see cref="T:MonoGame.Framework.WpfInterop.D3D11Image"/> should be disposed if no longer needed!
            </remarks>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Image.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MonoGame.Framework.WpfInterop.D3D11Image"/> class.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Image.Finalize">
            <summary>
            Releases unmanaged resources before an instance of the <see cref="T:MonoGame.Framework.WpfInterop.D3D11Image"/> class is 
            reclaimed by garbage collection.
            </summary>
            <remarks>
            This method releases unmanaged resources by calling the virtual <see cref="M:MonoGame.Framework.WpfInterop.D3D11Image.Dispose(System.Boolean)"/> 
            method, passing in <see langword="false"/>.
            </remarks>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Image.Dispose">
            <summary>
            Releases all resources used by an instance of the <see cref="T:MonoGame.Framework.WpfInterop.D3D11Image"/> class.
            </summary>
            <remarks>
            This method calls the virtual <see cref="M:MonoGame.Framework.WpfInterop.D3D11Image.Dispose(System.Boolean)"/> method, passing in 
            <see langword="true"/>, and then suppresses finalization of the instance.
            </remarks>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Image.Invalidate">
            <summary>
            Invalidates the front buffer. (Needs to be called when the back buffer has changed.)
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Image.SetBackBuffer(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Sets the back buffer of the <see cref="T:MonoGame.Framework.WpfInterop.D3D11Image"/>.
            </summary>
            <param name="texture">The Direct3D 11 texture to be used as the back buffer.</param>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Image.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by an instance of the <see cref="T:MonoGame.Framework.WpfInterop.D3D11Image"/> class 
            and optionally releases the managed resources.
            </summary>
            <param name="disposing">
            <see langword="true"/> to release both managed and unmanaged resources; 
            <see langword="false"/> to release only unmanaged resources.
            </param>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Image.InitializeD3D9">
            <summary>
            Initializes the Direct3D 9 device.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D11Image.UninitializeD3D9">
            <summary>
            Un-initializes the Direct3D 9 device, if no longer needed.
            </summary>
        </member>
        <member name="T:MonoGame.Framework.WpfInterop.D3D9">
            <summary>
            Represents a Direct3D 9 device required for Direct3D 11 interoperability.
            </summary>
            <remarks>
            It is not possible to set a Direct3D 11 resource (e.g. a texture or render target) in WPF
            directly because WPF requires Direct3D 9. The <see cref="T:MonoGame.Framework.WpfInterop.D3D9"/> class creates a new
            Direct3D 9 device which can be used for sharing resources between Direct3D 11 and Direct3D
            9. Call <see cref="M:MonoGame.Framework.WpfInterop.D3D9.GetSharedTexture(Microsoft.Xna.Framework.Graphics.Texture2D)"/> to convert a texture from Direct3D 11 to Direct3D 9.
            </remarks>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D9.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MonoGame.Framework.WpfInterop.D3D9"/> class.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D9.Finalize">
            <summary>
            Releases unmanaged resources before an instance of the <see cref="T:MonoGame.Framework.WpfInterop.D3D9"/> class is 
            reclaimed by garbage collection.
            </summary>
            <remarks>
            This method releases unmanaged resources by calling the virtual <see cref="M:MonoGame.Framework.WpfInterop.D3D9.Dispose(System.Boolean)"/> 
            method, passing in <see langword="false"/>.
            </remarks>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D9.Dispose">
            <summary>
            Releases all resources used by an instance of the <see cref="T:MonoGame.Framework.WpfInterop.D3D9"/> class.
            </summary>
            <remarks>
            This method calls the virtual <see cref="M:MonoGame.Framework.WpfInterop.D3D9.Dispose(System.Boolean)"/> method, passing in 
            <see langword="true"/>, and then suppresses finalization of the instance.
            </remarks>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D9.GetSharedTexture(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Creates Direct3D 9 texture from the specified Direct3D 11 texture. 
            (The content is shared between the devices.)
            </summary>
            <param name="renderTarget">The Direct3D 11 texture.</param>
            <returns>The Direct3D 9 texture.</returns>
            <exception cref="T:System.ArgumentException">
            The Direct3D 11 texture is not a shared resource, or the texture format is not 
            supported.
            </exception>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.D3D9.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by an instance of the <see cref="T:MonoGame.Framework.WpfInterop.D3D9"/> class 
            and optionally releases the managed resources.
            </summary>
            <param name="disposing">
            <see langword="true"/> to release both managed and unmanaged resources; 
            <see langword="false"/> to release only unmanaged resources.
            </param>
        </member>
        <member name="F:MonoGame.Framework.WpfInterop.Input.WindowHelper.FindWindow">
            <summary>
            Returns the window of the given control or null if unable to find a window.
            If null, the default implementation is used
            </summary>
            <returns></returns>
        </member>
        <member name="T:MonoGame.Framework.WpfInterop.Input.WpfKeyboard">
            <summary>
            Helper class that accesses a native API to get the current keystate.
            Required for any WPF hosted control.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.Input.WpfKeyboard.#ctor(System.Windows.IInputElement)">
            <summary>
            Creates a new instance of the keyboard helper.
            </summary>
            <param name="focusElement">The element that will be used as the focus point. Provide your implementation of <see cref="T:MonoGame.Framework.WpfInterop.WpfGame"/> here.</param>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.Input.WpfKeyboard.GetState">
            <summary>
            Gets the active keyboardstate.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MonoGame.Framework.WpfInterop.Input.WpfMouse">
            <summary>
            Helper class that converts WPF mouse input to the XNA/MonoGame <see cref="F:MonoGame.Framework.WpfInterop.Input.WpfMouse._mouseState"/>.
            Required for any WPF hosted control.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.Input.WpfMouse.#ctor(System.Windows.UIElement)">
            <summary>
            Creates a new instance of the keyboard helper.
            </summary>
            <param name="focusElement">The element that will be used as the focus point. Provide your implementation of <see cref="T:MonoGame.Framework.WpfInterop.WpfGame"/> here.</param>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.Input.WpfMouse.SetCursor(System.Int32,System.Int32)">
            <summary>
            Sets the cursor to the specific coordinates within the attached game.
            This is required as the monogame Mouse.SetPosition function relies on the underlying Winforms implementation and will not work with WPF.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="T:MonoGame.Framework.WpfInterop.WpfGame">
            <summary>
            The replacement for <see cref="T:Microsoft.Xna.Framework.Game"/>. Unlike <see cref="T:Microsoft.Xna.Framework.Game"/> the <see cref="T:MonoGame.Framework.WpfInterop.WpfGame"/> is a WPF control and can be hosted inside WPF windows.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.WpfGame.#ctor(System.String)">
            <summary>
            Creates a new instance of a game host panel.
            </summary>
        </member>
        <member name="P:MonoGame.Framework.WpfInterop.WpfGame.Components">
            <summary>
            Mirrors the
            </summary>
        </member>
        <member name="P:MonoGame.Framework.WpfInterop.WpfGame.Content">
            <summary>
            The content manager for this game.
            </summary>
        </member>
        <member name="P:MonoGame.Framework.WpfInterop.WpfGame.IsFixedTimeStep">
            <summary>
            Determines whether the game runs in fixed timestep or unlimited.
            Since WPF is limited to 60 FPS this value is always true.
            </summary>
        </member>
        <member name="P:MonoGame.Framework.WpfInterop.WpfGame.TargetElapsedTime">
            <summary>
            The target time between two updates. WPF itself is limited to 60 FPS max, so that's what this value always returns.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.WpfGame.Dispose(System.Boolean)">
            <summary>
            Dispose is called to dispose of resources.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.WpfGame.Draw(Microsoft.Xna.Framework.GameTime)">
            <summary>
            The draw method that is called to render your scene.
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.WpfGame.Initialize">
            <summary>
            Initialize is called once when the control is created.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.WpfGame.LoadContent">
            <summary>
            Load content is called once by <see cref="M:MonoGame.Framework.WpfInterop.WpfGame.Initialize"/>.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.WpfGame.Render(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Internal method used to integrate <see cref="M:MonoGame.Framework.WpfInterop.WpfGame.Update(Microsoft.Xna.Framework.GameTime)"/> and <see cref="M:MonoGame.Framework.WpfInterop.WpfGame.Draw(Microsoft.Xna.Framework.GameTime)"/> with the WPF control.
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.WpfGame.UnloadContent">
            <summary>
            Unload content is called once when the control is destroyed.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.WpfGame.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            The update method that is called to update your game logic.
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="T:MonoGame.Framework.WpfInterop.WpfGraphicsDeviceService">
            <summary>
            The <see cref="T:Microsoft.Xna.Framework.Content.ContentManager"/> needs a <see cref="T:Microsoft.Xna.Framework.Graphics.IGraphicsDeviceService"/> to be in the <see cref="T:System.ComponentModel.Design.IServiceContainer"/>. This class fulfills this purpose.
            </summary>
        </member>
        <member name="M:MonoGame.Framework.WpfInterop.WpfGraphicsDeviceService.#ctor(MonoGame.Framework.WpfInterop.D3D11Host)">
            <summary>
            Create a new instance of the dummy. The constructor will autom. add the instance itself to the <see cref="P:MonoGame.Framework.WpfInterop.D3D11Host.Services"/> container of <see cref="!:host"/>.
            </summary>
            <param name="host"></param>
        </member>
    </members>
</doc>
